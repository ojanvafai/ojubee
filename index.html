<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="/static/manifest.json">

    <link rel='stylesheet' href='/static/base.css' />
    <script src="/static/ecobee-api.js"></script>

    <script type="module">
      import tokenStore from '/static/tokens.js';
      import rlite from '/static/rlite.js';

      let g_pinResults;
      let g_thermostatSummary;
      var g_updateTimer;
      var g_updateFreqency = 30000;
      var g_thermostatId;
      var g_state;
      var g_tempsModified = false;
      var g_pendingRequests = new Map();

      function notFound() {
        return '<h1>404 Not found :/</h1>';
      }

/* TODO

V1
- Make refresh token cron work
- enable SW caching, make favicon work, make add to homescreen work, delete the public directory
- make loading thermostat/:id correctly do auth (do for all routes, not just home)
- require login so random people can't change our HVAC settings
- Make sure offline mostly works (e.g. that the fetch handlers do the right thing)

Perf
- stale-while-revalidate the list of thermostats to avoid jank in navbar
- do refresh token during idle time for faster page load? does that make sense even?

Code health
- Move config stuff to a different file so others can fork and use it too
- Clear listeners when nav'ing from one page to the next?
- Update README.md and TODO files
- Make all the callbacks be promises
- cleanup all the global code into modules
- load ecobee-api as a module
- move stylesheets into actual files?
- Abort pending fetches for a given key when starting a new one (requires either abortable fetch or using XHR)

*/

      const route = rlite(notFound, {
        '/': (params, state, url) => {
          renderHome();
        },
        'thermostat/:id': (params, state, url) => {
          g_thermostatId = params.id;
          setupThermostatPage();
          updateNavBarClassNames();
        },
      });

      window.onpopstate = () => {
        let html = route(location.pathname);
        if (html)
          document.body.innerHTML = html;
      }

      function updateNavBarClassNames() {
        var links = document.getElementById('nav').childNodes;
        for (var i = 0; i < links.length; i++) {
          let link = links[i];
          if (link.pathname == window.location.pathname)
            link.classList.add('current');
          else
            link.classList.remove('current');
        }
      }

      function appendLink(container, href, text) {
        var a = document.createElement('a');
        a.href = href;
        a.textContent = text;
        a.onclick = (e) => {
          e.preventDefault();
          history.pushState({}, null, a.pathname);
          route(a.pathname);
        };
        container.appendChild(a);
        // n^2, but n is at most 3 here, so don't care.
        updateNavBarClassNames();
      }

      function refreshAuth(callback) {
        function refreshFailed(msg) {
          console.log(msg);
          if (callback)
            renderPin();
          else
            document.body.innerHTML = "Error: " + msg;
        }

        tokenStore.get((tokens) => {
          if (!tokens) {
            refreshFailed("No refresh token.");
            return;
          }

          var refresh_token = tokens.refresh_token;
          console.log("Refreshing with these tokens:", JSON.stringify(tokens));
          var triesLeft = 3;

          var refreshTokens = () => {
            api.calls.refresh(refresh_token, function(err, registerResultObject) {
              if (err) { // if we error refreshing the token re-login
                console.log("Error refreshing token:", err);
                triesLeft--;

                if (triesLeft)
                  setTimeout(refreshTokens, 5000);
                else
                  refreshFailed(`Retried refreshing token ${REFRESH_TRY_COUNT} times before giving up.`);
              } else { // refresh of the tokens was successful to we can proceed to the main app
                console.log('New tokens:', registerResultObject);
                tokenStore.save(registerResultObject);
                callback();
              }
            });
          };
          refreshTokens();
        });
      };

      function getThermostatSummary(callback) {
        if (g_thermostatSummary)
          return callback(g_thermostatSummary);

        tokenStore.get((tokens) => {
          if (!tokens) {
            console.log("No auth tokens.");
            renderPin();
            return;
          }

          var thermostatSummaryOptions = new api.ThermostatSummaryOptions();
          api.calls.thermostatSummary(tokens.access_token, thermostatSummaryOptions, (err, summary) => {
            if (err) {
              console.log("Couldn't get thermostat summary.", err);
              renderPin();
              return;
            }

            var thermostatArray = [];
            for( var i = 0; i < summary.revisionList.length; i ++) {
              var revisionArray = summary.revisionList[i].split(':');
              thermostatArray.push({ name: revisionArray[1], id: revisionArray[0]} );
            }

            g_thermostatSummary = thermostatArray;
            callback(g_thermostatSummary);
          });
        });

      }

      function sortByName(a, b) {
        if (a.name > b.name)
          return 1;
        if (a.name < b.name)
          return -1;
        return 0;
      }

      function divide10(num) {
        return num / 10;
      }

      function addRequest(key, request) {
        let old = g_pendingRequests.get(key);
        if (old)
          old.abort();
        g_pendingRequests.set(key, request);
      }

      function updateThermostat(id) {
        let spinnerKey = 'updateThermostat';
        showSpinner(spinnerKey);

        tokenStore.get((tokens) => {
          if (!tokens) {
            console.log("No auth tokens.");
            renderPin();
            return;
          }

          let thermostatsOptions = new api.ThermostatsOptions(id);

          let request = api.calls.thermostats(tokens.access_token, thermostatsOptions, function(err, thermostats) {
            hideSpinner(spinnerKey);
            if (err) {
              console.log("Couldn't refresh token.", err);
              return;
            }
            updateStateLoad(thermostatState(thermostats.thermostatList[0]));
          });

          addRequest(spinnerKey, request);
        });

        return id;
      }

      function applyOnState(idPrefix, keyword) {
        var id = idPrefix + 'On';
        if (g_state.equipmentStatus.indexOf(keyword) == -1)
          document.getElementById(id).classList.remove(id);
        else
          document.getElementById(id).classList.add(id);
      }

      function applyState() {
        var html = '';
        g_state.sensors.forEach(function(sensor) {
          html += '<div>' + sensor.name + ': ' + sensor.temp + '</div>';
        });
        document.getElementById('sensors').innerHTML = html;

        ["currentTemp", "desiredCool", "desiredHeat",].forEach((id) => {
          document.getElementById(id).textContent = g_state[id];
        });

        var mode = document.getElementById('mode');
        for (var i = 0; i < mode.length; i++) {
          if (mode.item(i).value == g_state.mode) {
            mode.selectedIndex = i;
            break;
          }
        }

        var fan = document.getElementById('fan');
        fan.setAttribute('state', g_state.desiredFanMode);

        var override = document.getElementById('override');
        override.textContent = g_state.overrideTime ? `Held until ${g_state.overrideTime}` : '';

        var resume = document.getElementById('resume');
        if (g_state.overrideTime)
          resume.classList.remove('hidden');
        else
          resume.classList.add('hidden');

        applyOnState('heat', 'auxHeat');
        applyOnState('cool', 'compCool');
        applyOnState('fan', 'fan');
      }

      function thermostatState(thermostat) {
        var sensors = [];
        thermostat.remoteSensors.forEach((sensor) => {
          sensor.capability.forEach((capability) => {
            if (capability.type == 'temperature')
              sensors.push({
                name: sensor.name,
                temp: parseInt(capability.value, 10) / 10,
              });
          })
        });

        var overrideTime;
        if (thermostat.events.length > 1) {
          // TODO: Probably shouldn't hard code this and instead just check
          // if the data is more than a year out.
          if (thermostat.events[0]['endDate'] == '2035-01-01') {
            overrideTime = 'âˆž';
          } else {
            var endTime = thermostat.events[0]['endTime'];
            var parts = endTime.split(':');
            var hours = Number(parts[0]);
            var minutes = parts[1];
            var suffix;
            if (hours < 12) {
              suffix = 'AM';
              if (hours == 0)
                hours = 12;
            } else {
              suffix = 'PM';
              if (hours != 12)
                hours -= 12;
            }

            overrideTime = `${hours}:${minutes} ${suffix}`;
          }
        }

        var allowedHeatRange = thermostat.runtime.desiredHeatRange.map(divide10);
        var allowedCoolRange = thermostat.runtime.desiredCoolRange.map(divide10);

        // Ensure allowed ranges keep a distance of 5 since the thermostat
        // does that on it's own and gives weird errors if you try to do
        // differences less than 5.
        if (allowedHeatRange[0] + 5 > allowedCoolRange[0])
          allowedCoolRange[0] = allowedHeatRange[0] + 5;

        if (allowedCoolRange[1] - 5 < allowedHeatRange[1])
          allowedHeatRange[1] = allowedCoolRange[1] - 5;

        return {
          currentTemp: thermostat.runtime.actualTemperature / 10,
          desiredCool: thermostat.runtime.desiredCool / 10,
          desiredHeat: thermostat.runtime.desiredHeat / 10,
          allowedHeatRange: allowedHeatRange,
          allowedCoolRange: allowedCoolRange,
          desiredFanMode: thermostat.runtime.desiredFanMode,
          overrideTime: overrideTime,
          mode: thermostat.settings.hvacMode,
          name: thermostat.name,
          sensors: sensors.sort(sortByName),
          thermostatId: thermostat.identifier,
          equipmentStatus: thermostat.equipmentStatus,
        };
      }

      function updateStateLoad(newState) {
        if (newState.error) {
          window.location = newState.redirectUrl + window.location.pathname;
          return;
        }

        // Check if desiredCool/heat don't match early return and
        // issue another updateTemp request and loop through till it takes.
        if (g_tempsModified && g_state &&
            (newState.desiredHeat != g_state.desiredHeat ||
             newState.desiredCool != g_state.desiredCool)) {
          console.log("Numbers didn't take. Retrying.",
            newState.desiredHeat, g_state.desiredHeat,
            newState.desiredCool, g_state.desiredCool);
          setTimeout(updateTemp, 1000);
          return;
        }

        document.getElementById('container').classList.remove('hidden');
        document.getElementById('load-spinner').style.display = 'none';

        g_tempsModified = false;
        g_state = newState;
        applyState();
      }

      function updateState() {
        updateThermostat(g_thermostatId);
      }

      function resumeSchedule() {
        var onError = () => {
          updateState();
          alert('Resume schedule failed. Reload the page to be safe.');
        };

        var updateFunction = new api.ResumeProgramFunction();
        var options = new api.ThermostatsUpdateOptions(g_thermostatId, [updateFunction]);
        updateThermostats(options, updateState, onError, 'resumeSchedule');
      }

      window.resumeSchedule = resumeSchedule;

      function encodedValue(id) {
        // TODO: spaces as '+'
        return id + '=' + encodeURIComponent(g_state[id]);
      }

      function toggleFan() {
        if (g_state.desiredFanMode == 'auto')
          g_state.desiredFanMode = 'on';
        else
          g_state.desiredFanMode = 'auto';

        applyState();
        updateTemp();
      }

      window.toggleFan = toggleFan;

      function modifyTemp(id, delta) {
        g_tempsModified = true;
        g_state[id] = g_state[id] + delta;

        // Must have a minimum of 5 degrees difference.
        // Otherwise the server tries to do this logic but
        // goes crazy and uses fractional values.
        if (g_state.desiredCool - g_state.desiredHeat < 5) {
          if (id == 'desiredHeat')
            g_state.desiredCool = g_state.desiredHeat + 5;
          else
            g_state.desiredHeat = g_state.desiredCool - 5;
        }

        if (g_state.desiredCool < g_state.allowedCoolRange[0])
          g_state.desiredCool = g_state.allowedCoolRange[0];
        if (g_state.desiredHeat < g_state.allowedHeatRange[0])
          g_state.desiredHeat = g_state.allowedHeatRange[0];
        if (g_state.desiredCool > g_state.allowedCoolRange[1])
          g_state.desiredCool = g_state.allowedCoolRange[1];
        if (g_state.desiredHeat > g_state.allowedHeatRange[1])
          g_state.desiredHeat = g_state.allowedHeatRange[1];

        applyState();
        updateTemp();
      }

      window.modifyTemp = modifyTemp;

      // This rounding shouldn't be necessary, but ecobee sometimes returns
      // fractional values and everything gets confused.
      // Seems to happen if you try to set temp values that aren't allowed,
      // e.g. at the bounds of allowed, or hot/cold too close to each other.
      function roundTempValues(state) {
        state.desiredHeat = Math.round(state.desiredHeat);
        state.desiredCool = Math.round(state.desiredCool);
      }

      function showSpinner(key) {
        let spinner = document.getElementById('spinner');
        if (spinner)
          spinner.classList.remove('hidden');
      }

      function hideSpinner(key) {
        let spinner = document.getElementById('spinner');
        if (spinner)
          spinner.classList.add('hidden');
      }


      function updateThermostats(options, onSuccess, onError, spinnerKey) {
        showSpinner(spinnerKey);
        tokenStore.get((tokens) => {
          if (!tokens) {
            console.log("No auth tokens");
            renderPin();
            return;
          }

          let request = api.calls.updateThermostats(tokens.access_token, options, (err, val) => {
            hideSpinner(spinnerKey);
            if (err)
              onError("Couldn't update thermostats.", err);
            else
              onSuccess(val);
          });
          addRequest(spinnerKey, request);
        });
      }

      function temperatureAsInt(temp) {
        return parseInt(temp, 10) * 10; // our canonical form is F * 10
      }

      function updateTemp() {
        var onError = () => {
          updateState();
          alert('Update failed. Reload the page to be safe.');
        };

        roundTempValues(g_state);
        var desiredCool = temperatureAsInt(g_state.desiredCool);
        var desiredHeat = temperatureAsInt(g_state.desiredHeat);
        var fan = g_state.desiredFanMode;
        var duration = document.getElementById('duration').selectedOptions[0].value;
        // hold_type values: dateTime, nextTransition, indefinite, holdHours.
        // https://www.ecobee.com/home/developer/api/documentation/v1/functions/SetHold.shtml
        var updateFunction = new api.SetHoldFunction(desiredCool, desiredHeat, fan, duration);
        var options = new api.ThermostatsUpdateOptions(g_thermostatId, [updateFunction]);
        updateThermostats(options, updateState, onError, 'updateTemp');
      }

      function updateMode() {
        var onError = () => {
          updateState();
          alert('Update failed. Reload the page to be safe.');
        };

        var newMode = document.getElementById('mode').selectedOptions[0].value;
        var thermostats_update_options = new api.ThermostatsUpdateOptions(g_thermostatId);
        var settings = new api.ModeUpdateSettings(newMode);
        var options = new api.ThermostatsUpdateOptions(g_thermostatId, null, settings);
        updateThermostats(options, updateState, onError, 'updateMode');
      }

      window.updateMode = updateMode;

      function startUpdates() {
        if (g_updateTimer)
          return;
        updateState();
        g_updateTimer = setInterval(updateState, g_updateFreqency);
      }

      function stopUpdates() {
        if (!g_updateTimer)
          return;
        clearInterval(g_updateTimer);
        g_updateTimer = null;
      }

      function setupThermostatPage() {
        // Hacktastic. Should have cleared state when left previous page
        // so this will restart.
        updateState();

        // Also hacktastic way of making it so we don't register
        // these multiple times.
        if (!g_updateTimer) {
          window.addEventListener('focus', startUpdates);
          window.addEventListener('blur', stopUpdates);
          window.addEventListener('visibilityChange', () => {
            if (document.visibilityState == 'visible')
              startUpdates();
            else
              stopUpdates();
          });

          if (document.visibilityState == 'visible')
            startUpdates();
        }

        document.body.innerHTML = `
<style>
  * {
    flex-wrap: wrap;
    min-width: min-content;
    white-space: nowrap;
  }
  .offline #container {
    opacity: 0;
    pointer-events: none;
  }
  .offline::before {
    content: "You are offline.";
  }
  #container {
    position: relative;
    display: flex;
    flex-direction: column;
    flex: 1;
    transition: opacity 0.5s;
  }
  #container.hidden {
    flex: 0;
  }
  #details {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: auto;
  }
  #details > .split-container {
    font-size: 20px;
  }
  img {
    width: 50px;
    min-width: 0px;
  }
  #load-spinner {
    display: flex;
    flex: 1;
    align-items: center;
    justify-content: center;
  }
  #spinner {
    opacity: 1;
    margin: 5px;
    transition: opacity 0.5s;
  }
  #container.hidden #spinner {
    opacity: 0;
  }
  #override {
    font-size: 20px;
  }
  .split-container {
    display: flex;
    position: relative;
  }
  .split-container > .item {
    flex: 1;
    margin: 5px;
  }
  .split-container .button {
    border: 1px solid;
    padding: 10px 0;
    font-size: 60px;
    background: white;
    text-align: center;
    user-select: none;
  }
  #top-toolbar {
    display: flex;
  }
  #top-toolbar > * {
    flex: 1;
  }
  #sensors {
    display: flex;
    flex-direction: column;
  }
  #temps > *,
  #state > * {
    display: flex;
  }
  #fan[state=on] {
    background-color: #ccc;
  }
  .fill {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    pointer-events: none;

    display: flex;
    align-items: center;
    justify-content: center;
  }
  .center {
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
  }
  .temp {
    font-size: 60px;
    font-weight: bold;
    /* Picked to satisfy lighthouse contrast requirements. */
    opacity: 0.64;
  }
  .hvacState {
    width: 40px;
    height: 40px;
    border: 1px solid white;

    display: flex;
    align-items: center;
    justify-content: center;
  }
  .heatOn {
    background-color: pink;
  }
  .coolOn {
    background-color: lightblue;
  }
  .fanOn {
    background-color: #aaa;
  }
  .heat {
    color: red;
  }
  .cool {
    color: blue;
  }
</style>
<div id="load-spinner">
  <img alt="Loading spinner" src="/static/spinner.gif">
</div>

<div id="container" class="hidden">
  <div style="position: absolute; right: 5px; top: 5px;"><img id="spinner" class="hidden" alt="Loading spinner" src="/static/spinner.gif"></div>

  <div id="details">
    <div class="split-container">
      <div class="item" id="temps">
        <div>Total:&nbsp;<span id="currentTemp"></span></div>
        <div id="sensors"></div>
      </div>

      <div class="item" id="state">
        <div style="display: flex; justify-content: space-between; width: 140px; margin-bottom: 5px;">
          <div id="coolOn" class="hvacState">Cool</div>
          <div id="heatOn" class="hvacState">Heat</div>
          <div id="fanOn" class="hvacState">Fan</div>
        </div>

        <label>Mode:
          <select id="mode" onchange="updateMode()">
            <option value="heat">Heat</option>
            <option value="cool">Cool</option>
            <option value="auto">Auto</option>
            <option value="off">Off</option>
          </select>
        </label>

        <label>Hold:
          <select id="duration">
            <option value="2">2 hours</option>
            <option value="4">4 hours</option>
            <option selected value="nextTransition">Next transition</option>
            <option value="indefinite">Indefinite</option>
          </select>
        </label>
      </div>
    </div>
  </div>

  <div>
    <div class="split-container">
      <div id="resume" class="button item center" onclick="resumeSchedule()">
        <div style="font-size: 30px">Resume</div>
        <div id="override"></div>
      </div>
      <div id="fan" class="button item" onclick="toggleFan()">Fan</div>
    </div>

    <div class="split-container">
      <div class="cool temp fill" id="desiredCool"></div>
      <div class="button item" onclick="modifyTemp('desiredCool', -1)">-</div>
      <div class="button item" onclick="modifyTemp('desiredCool', 1)">+</div>
    </div>

    <div class="split-container">
      <div class="heat temp fill" id="desiredHeat"></div>
      <div class="button item" onclick="modifyTemp('desiredHeat', -1)">-</div>
      <div class="button item" onclick="modifyTemp('desiredHeat', 1)">+</div>
    </div>
  </div>
</div>
<div id="nav"></div>
`;

        var navBar = document.getElementById('nav');
        appendLink(navBar, "/", "Ojubee");
        getThermostatSummary((summary) => {
          summary.forEach((thermostat) => {
            appendLink(navBar, `/thermostat/${thermostat.id}`, thermostat.name);
          });
        });
      }

      function renderHome() {
        getThermostatSummary((summary) => {
          document.body.innerHTML = `
              <style>
                body {
                  font-size: 40px;
                }
                a {
                  text-decoration: none;
                  color: black;
                }
                #container {
                  display: flex;
                  flex-direction: column;
                }
                #container > * {
                  display: flex;
                  align-items: center;
                  justify-content: center;

                  border: 1px solid;
                  padding: 30px;
                  margin: 0 30px 30px;
                  background-color: white;
                }
                #title {
                  flex: 1;
                  display: flex;
                  align-items: center;
                  justify-content: center;
                }
              </style>
              <div id="title">Ojubee</div>
              <div id="container">
              </div>
              <div id="nav"></div>
              `;

          var container = document.getElementById('container');
          summary.forEach((thermostat) => {
            appendLink(container, `/thermostat/${thermostat.id}`, thermostat.name);
          });
        });
      }

      function renderPin() {
        // This should try to refresh tokens first.
        api.calls.getPin(config.appKey, config.scope, function(err, pinResults) {
          g_pinResults = pinResults;
          document.body.innerHTML = `<h2>Step 1</h2>
            <p>Go to your ecobee portal under the settings tab and add this application using the pin code below</p>
            <div class="pin">
            <p class="lead">pin code: ${ pinResults.ecobeePin }</p>
            </div>
            <h2>Step 2</h2>
            <p>Once you have authorized this app to have access to your account you may log in by clicking the Complete Link button below.</p>
            <button onclick="login()">Complete Link</button>`;
        });
      }

      function login() {
        var code = g_pinResults.code;
        var appKey = config.appKey;
        var scope = config.scope;

        api.calls.registerPin(appKey, code, function(err, registerResultObject) {
          var tooFast = false;
          if (err) {
            console.log(err)

            var interval = g_pinResults.interval;
            var errorMessage = '';

            if (err.data && err.data.error && err.data.error === 'slow_down') {
              errorMessage = 'Polling too fast: Please wait ' + interval + ' seconds before attempting to complete the link again.';
              tooFast = true;
            } else {
              errorMessage = 'You must first authorize the app on your ecobee portal settings page. Then click the complete link button below.';
            }

            alert(errorMessage);
            setTimeout(login, (interval + 1) * 1000);
          } else {
            console.log('New tokens:', registerResultObject);
            tokenStore.save(registerResultObject);
            renderHome();
          }
        });
      };

      window.login = login;

      window.addEventListener('DOMContentLoaded', refreshAuth(() => {
        route(location.pathname);
      }));
    </script>
  </head>

  <body>
  </body>
</html>
